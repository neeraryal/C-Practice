Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.

In other words, return true if one of s1's permutations is the substring of s2.

 

Example 1:

Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").
Example 2:

Input: s1 = "ab", s2 = "eidboaoo"
Output: false

```c
bool checkInclusion(char* s1, char* s2) {
    int * count_arr= calloc(26, sizeof(int));
    int character_count=0;
    for (int i=0 ;s1[i]!='\0';i++)
    {
        count_arr[s1[i]-'a']++;
        character_count++;
    }
    int index=0;
    while(s2[index]!='\0')
    {
        count_arr[s2[index]-'a']--;
        if(index>=character_count) //If window length rech or exceeds, we maintin it.
        {
            count_arr[s2[index-character_count]-'a']++;
        }
        int i=0;
        while(i<26)//We rechek after ading and maintaining window that all are inside window, if yes then all will be 0.
        {
            if(count_arr[i]!=0) break;
            i++;
        }
        if(i==26) return true; //If all are 0, that means current window has s1 in in it.
        index++;
    }
    free(count_arr);
    return false;
    
}
```


```c
bool checkInclusion(char* s1, char* s2) {
    int * frequency=calloc(26,sizeof(int));
    int required=0;
    for(int i=0;s1[i]!='\0';i++)
    {
        frequency[(unsigned char)s1[i]-'a']++;
        required++;
    }

    int * matched_frequency=calloc(26,sizeof(int));
    
    int left=0,right=0;
    int matched=0;
    while (s2[right]!='\0')
    {
        char c=s2[right];
        int right_index=(unsigned char)c-'a';
        
        // Add character to window
        matched_frequency[right_index]++;
        if(frequency[right_index]>0 && matched_frequency[right_index]<=frequency[right_index])
            matched++;

        // Shrink window from left while it's invalid or too large
        while(matched_frequency[right_index] > frequency[right_index] || matched > required)
        {
            int left_index=(unsigned char)s2[left]-'a';
            if(frequency[left_index]>0 && matched_frequency[left_index]<=frequency[left_index])
                matched--;
            matched_frequency[left_index]--;
            left++;
        }

        if(matched==required) 
        {
            free(frequency);
            free(matched_frequency);
            return true;
        }
        
        right++;
    }
    free(frequency);
    free(matched_frequency);
    return false;
}
```