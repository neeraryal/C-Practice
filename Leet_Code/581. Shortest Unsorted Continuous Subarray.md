Given an integer array nums, you need to find one continuous subarray such that if you only sort this subarray in non-decreasing order, then the whole array will be sorted in non-decreasing order.

Return the shortest such subarray and output its length.

 

Example 1:

Input: nums = [2,6,4,8,10,9,15]
Output: 5
Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.
Example 2:

Input: nums = [1,2,3,4]
Output: 0
Example 3:

Input: nums = [1]
Output: 0

```
Intution : Worst case : 
1) Create a copy and sort it.
2) Now Check the first index from left where there is a mismatch, same from right, and return right-left=1 

O(n) Solution : Intution: Sorted array propery :- Every element on left is small and every element on right is bigger than current index.

1) Iterate from left to right, it should be in increasing order.
2) Store the index where , increasing order fails as it needs to be corrected.

3) Iterrate from right to left , it should be in decreasing order.
4) Store the index where, decreasing order fails as it needs to be corrected.

```

```c

int findUnsortedSubarray(int* arr, int n) {

    int left=0, right=n-1;
    int max_seen= INT_MIN,min_seen=INT_MAX; 
    int right_boundary=-1, left_boundary=-1;
    while(left<n)
    {
        if(arr[left]<max_seen)
        {
            right_boundary=left;
        }
        else
            max_seen=arr[left];
        left++;
    }

    if (right_boundary == -1)
    return 0;
    
    while(right>=0)
    {
        if(arr[right]>min_seen)
        {
            left_boundary=right;
        }
        else 
            min_seen=arr[right];
        right--;
    }

    return right_boundary-left_boundary+1;
}

```