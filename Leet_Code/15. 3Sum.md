Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.

 

Example 1:

Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
Example 2:

Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
Example 3:

Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int cmp_int(const void *a, const void *b)
{
    int x = *(const int *)a;
    int y = *(const int *)b;

    if (x < y) return -1;
    if (x > y) return 1;
    return 0;
}

```c
int** threeSum(int* arr, int n, int* returnSize, int** returnColumnSizes)
{
    qsort(arr, n, sizeof(int), cmp_int);

    int capacity = 1000;
    int** res = malloc(sizeof(int*) * capacity);
    int* col_arr = malloc(sizeof(int) * capacity);

    int res_index = 0;

    for (int i = 0; i < n - 2 && arr[i] <= 0; i++)
    {
        if (i > 0 && arr[i] == arr[i - 1]) continue;

        int left = i + 1;
        int right = n - 1;
        int target = -arr[i];

        while (left < right)
        {
            int sum = arr[left] + arr[right];

            if (sum == target)
            {
                if (res_index == capacity)
                {
                    capacity *= 2;
                    res = realloc(res, sizeof(int*) * capacity);
                    col_arr = realloc(col_arr, sizeof(int) * capacity);
                }

                int* triplet = malloc(sizeof(int) * 3);
                triplet[0] = arr[i];
                triplet[1] = arr[left];
                triplet[2] = arr[right];

                res[res_index] = triplet;
                col_arr[res_index] = 3;
                res_index++;

                left++;
                right--;

                while (left < right && arr[left] == arr[left - 1]) left++;
                while (left < right && arr[right] == arr[right + 1]) right--;
            }
            else if (sum < target)
                left++;
            else
                right--;
        }
    }

    *returnSize = res_index;
    *returnColumnSizes = col_arr;
    return res;
}
```

Realloc Code for reference 

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n=10;
    int capacity=5;
    int *arr= malloc(sizeof(int)*capacity);
    for(int i=0 ;i<n;i++)
    {
        if(i>=capacity)
        {
            capacity*=2;
            int*temp=NULL;
            temp=realloc(arr, sizeof(int)*capacity); //Why temp ? we can assign arr directly , but what if there is no memory , then   it will fail and we'll loose arr as well.
            if(temp ==NULL)
            {
                free(arr);
                return 1;
            }
            arr=temp;
        }
        arr[i]=i;
    }
    
    for (int i=0 ;i<n ;i++)
    {
        printf("%3d",*(arr+i));
    }
    return 0;
}
```